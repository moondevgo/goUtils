// [Golang mongo Document](https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.9.0/mongo)
// [MongoDB Golang Reference](https://www.mongodb.com/docs/drivers/go/current/fundamentals/crud/read-operations/project/)

// [Golang + MongoDB으로 CRUD 구현하기](https://soyoung-new-challenge.tistory.com/107)

// [https://flyingsquirrel.medium.com/go로-mongodb에-쿼리-날리기-da10a91aba33](https://flyingsquirrel.medium.com/)

// [MongoDB Go Driver Tutorial Part 1: Connecting, Using BSON, and CRUD Operations](https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial-part-1-connecting-using-bson-and-crud-operations)

package database

import (
	"context"
	"fmt"
	"log"

	// "time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	// "go.mongodb.org/mongo-driver/mongo/readpref"
	// "go.mongodb.org/mongo-driver/mongo"
	// "go.mongodb.org/mongo-driver/mongo/options"

	"github.com/moondevgo/go-mods/basic"
)

// const (
// 	YAML_NAME = "database_conn"
// )

// func GetClientOptions(serverName string, auth bool) (clientOptions *options.ClientOptions) {
// 	YAML_NAME := "database_conn"
// 	// serverName := "mongo_Oracle3_root_ex"
// 	config := env.GetConfigYaml(YAML_NAME, serverName)

// 	if auth {
// 		// var (
// 		// 	dbUrl = "mongodb://%s:%v"
// 		// 	dbUrlAuth = "mongodb://%s:%v@%s:%v"
// 		// )
// 		// url := fmt.Sprintf(setGroupStateURL, "10.0.0.18", "0A498B9909", groupID)
// 		clientOptions = options.Client().ApplyURI(fmt.Sprintf("mongodb://%s:%v", config["host"], config["port"])).SetAuth(options.Credential{
// 			Username: config["user"].(string),
// 			Password: config["password"].(string),
// 		})
// 	} else {
// 		uri := fmt.Sprintf("mongodb://%s:%s@%s:%v", config["user"], config["password"], config["host"], config["port"])
// 		clientOptions = options.Client().ApplyURI(uri)
// 	}

// 	return clientOptions

// }

// // ConnectDB to MongoDB
// func ConnectMongoDB(serverName string, auth bool) (client *mongo.Client, ctx context.Context, cancel context.CancelFunc) {
// 	// Timeout 설정을 위한 Context생성
// 	ctx, cancel = context.WithTimeout(context.Background(), 3*time.Second)
// 	clientOptions := GetClientOptions(serverName, false)

// 	// MongoDB 연결
// 	client, err := mongo.Connect(ctx, clientOptions)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	err = client.Ping(ctx, readpref.Primary()) // Primary DB에 대한 연결 체크
// 	if err != nil {
// 		log.Fatal(err)
// 	}

// 	// return client, ctx
// 	return client, ctx, cancel
// }

func GetCollection(colName, dbName string, client *mongo.Client) *mongo.Collection {
	return client.Database(dbName).Collection(colName)
}

func MgFindOneBsonD(filter, project bson.D, colName, dbName string, client *mongo.Client) (result map[string]interface{}) {
	collection := client.Database(dbName).Collection(colName)
	opts := options.FindOne().SetProjection(project)
	err := collection.FindOne(context.TODO(), filter, opts).Decode(&result)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Found the document: %+v\n", result)
	return result
}

func MgFindOne(filter, project map[string]interface{}, colName, dbName string, client *mongo.Client) map[string]interface{} {
	return MgFindOneBsonD(basic.Map2BsonD(filter), basic.Map2BsonD(project), colName, dbName, client)
}

func MgFindBsonD(filter, project bson.D, colName, dbName string, client *mongo.Client) (results []map[string]interface{}) {
	collection := client.Database(dbName).Collection(colName)
	opts := options.Find().SetProjection(project)
	cursor, err := collection.Find(context.TODO(), filter, opts)

	if err != nil {
		fmt.Println(err)
	}
	for cursor.Next(context.TODO()) {
		// var elem bson.M
		var elem map[string]interface{}
		err := cursor.Decode(&elem)
		if err != nil {
			fmt.Println(err)
		}
		results = append(results, elem)
	}

	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Found the document: %+v\n", results)
	return results
}

func MgFind(filter, project map[string]interface{}, colName, dbName string, client *mongo.Client) (results []map[string]interface{}) {
	return MgFindBsonD(basic.Map2BsonD(filter), basic.Map2BsonD(project), colName, dbName, client)
}

func MgInsertOneBsonD(data bson.D, colName, dbName string, client *mongo.Client) error {
	_, err := client.Database(dbName).Collection(colName).InsertOne(context.TODO(), data) // insertResult, err
	return err
}

func MgInsertOne(data map[string]interface{}, colName, dbName string, client *mongo.Client) error {
	return MgInsertOneBsonD(basic.Map2BsonD(data), colName, dbName, client)
}

func MgInsertBsonD(datas []interface{}, colName, dbName string, client *mongo.Client) error {
	_, err := client.Database(dbName).Collection(colName).InsertMany(context.TODO(), datas) // insertResult, err
	return err
}

func MgInsert(datas []map[string]interface{}, colName, dbName string, client *mongo.Client) error {
	var bsons []interface{}
	for _, data := range datas {
		bsons = append(bsons, basic.Map2BsonD(data))
	}
	return MgInsertBsonD(bsons, colName, dbName, client)
}

func MgUpdateOne(colName, dbName string, client *mongo.Client) {
	filter := bson.D{{"a", 3}}

	update := bson.D{
		{"$inc", bson.D{
			{"b", 100},
		}},
	}

	updateResult, err := client.Database(dbName).Collection(colName).UpdateOne(context.TODO(), filter, update)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(updateResult)
}

// func (coll *Collection) UpdateMany(ctx context.Context, filter interface{}, update interface{},
// 	opts ...*options.UpdateOptions) (*UpdateResult, error)

func MgDelete() {
	// filter := bson.D{{"rating", bson.D{{"$gt", 8}}}}
	// opts := options.Delete().SetHint(bson.D{{"_id", 1}})
	// result, err := coll.DeleteMany(context.TODO(), filter, opts)
	// if err != nil {
	//    panic(err)
	// }
	// fmt.Printf("Number of documents deleted: %d\n", result.DeletedCount)
}
